<% if user_signed_in? %>
	<h1>User: <%= current_user.email %>, Role: <%= current_user.role %>, Kind: <%= current_user.kind %></h1>
<% end %>

<% if user_signed_in? %>
<% else %>
    <div class="row">
        <div class="col-md-12">
            <h1>Plataforma de modelaje y fotograf√≠a en Cuba</h1>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            Obten servicio
        </div>
        <div class="col-md-6">
            <h2>Se descubierto!</h2>
            <div class="well">
                <h2>Modelo Profesional</h2>
                <h2>Modelo Aficionado</h2>
                <h2>Fotografo</h2>
            </div>
            <button class="btn btn-success btn-lg" type="button" data-toggle="collapse" data-target="#collapse-sign-up-form" aria-expanded="false" aria-controls="collapse-sign-up-form">
                Register now and rise your carreer
            </button>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12">
            <div class="collapse" id="collapse-sign-up-form">
                <div class="row">
                    <div class="col-md-7">
                        <h1>Some text</h1>
                    </div>
                    <div class="col-md-4">
                        <%= render "layouts/sign_up_home_page" %>
                    </div>
                </div>
            </div>
        </div>
    </div>
<% end %>

<div class="row">
    <div class="col-md-6">
      <p>
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
      </p>
    </div>
    <div class="col-md-6">
      <p>
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
        # Puma can serve each request in a thread from an internal thread pool.
        # The `threads` method setting takes two numbers a minimum and maximum.
        # Any libraries that use thread pools should be configured to match
        # the maximum value specified for Puma. Default is set to 5 threads for minimum
        # and maximum, this matches the default thread size of Active Record.
        #
        threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }.to_i
        threads threads_count, threads_count

        # Specifies the `port` that Puma will listen on to receive requests, default is 3000.
        #
        port        ENV.fetch("PORT") { 3000 }

        # Specifies the `environment` that Puma will run in.
        #
        environment ENV.fetch("RAILS_ENV") { "development" }

        # Specifies the number of `workers` to boot in clustered mode.
        # Workers are forked webserver processes. If using threads and workers together
        # the concurrency of the application would be max `threads` * `workers`.
        # Workers do not work on JRuby or Windows (both of which do not support
        # processes).
        #
        # workers ENV.fetch("WEB_CONCURRENCY") { 2 }

        # Use the `preload_app!` method when specifying a `workers` number.
        # This directive tells Puma to first boot the application and load code
        # before forking the application. This takes advantage of Copy On Write
        # process behavior so workers use less memory. If you use this option
        # you need to make sure to reconnect any threads in the `on_worker_boot`
        # block.
        #
        # preload_app!

        # The code in the `on_worker_boot` will be called if you are using
        # clustered mode by specifying a number of `workers`. After each worker
        # process is booted this block will be run, if you are using `preload_app!`
        # option you will want to use this block to reconnect to any threads
        # or connections that may have been created at application boot, Ruby
        # cannot share connections between processes.
        #
        # on_worker_boot do
        #   ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
        # end

        # Allow puma to be restarted by `rails restart` command.
        plugin :tmp_restart
      </p>
    </div>
    <div class="clearfix"></div>
</div>